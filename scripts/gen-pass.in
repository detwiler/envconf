#! /bin/env bash

# functions

function usage()
{
	cat <<- eof

	Usage: $(basename $0) [-p <prologue>] [-s <salt>] [-e <epilogue>] \\
	  [-a <hash-algorithm>] [-r <bytes>] [-i <byte>] [-f <bytes>] \\
	  [-t] [-u | -b | -c]

	  -p proloque
	  -s salt (if neither -s nor -r specified, user will be prompted)
	  -e epilogue
	  -a secure hash algorithm [1|224|256|384|512] (default: SHA-1)
	  -r use ARG bytes of random salt
	  -i initial byte of digest to begin with
	  -f discard ARG final bytes of digest
	  -t convert digest to text
	  -u uuencode digest
	  -b base64 encode digest
	  -c ascii85 encode digest

	Examples:

	$(basename $0) -p foo -e bar -a 224 -r 32 -t -u

	eof
} # usage()

function cleanup()
{
  local size="$(stat --printf='%s' $message)"
  head --bytes=$size /dev/urandom >$message
  size="$(stat --printf='%s' $digest)"
  head --bytes=$size /dev/urandom >$digest
  rm -f $message $digest
} # cleanup()

function get_salt()
{
  read -s -p 'Enter salt: ' salt
  read -s -p 'Confirm salt: ' check

  if [[ $salt != $check ]]; then
    echo 'Salt entries did not match!' >/dev/stderr
    exit 1
  fi
} # get_salt()

salt=''
prologue=''
epilogue=''
sha=''
random=''
text=''
initial='1'
final='0'
uuencode=''
base64=''
ascii85=''
encode=''

while getopts "p:s:e:a:r:i:f:tubch" opt; do
  case $opt in
    p ) prologue=$OPTARG ;;
    s ) salt=$OPTARG ;;
    e ) epilogue=$OPTARG ;;
    a ) sha=$OPTARG ;;
    r ) random=$OPTARG ;;
    i ) initial=$OPTARG ;;
    f ) final=$OPTARG ;;
    t ) text='true' ;;
    u ) uuencode='true' ;;
    b ) base64='true' ;;
    c ) ascii85='true' ;;
    h ) usage >/dev/stderr; exit 0 ;;
    \? ) usage >/dev/stderr; exit 1 ;;
  esac
done

shift $(($OPTIND - 1))

if [[ -n $uuencode && ( -n $base64 || -n $ascii85 ) ]]; then
  echo 'Only one encoding may be selected!' >/dev/stderr
  exit 1
fi

if [[ -n $base64 ]]; then
  if [[ -n $ascii85 ]]; then
    echo 'Only one encoding may be selected!' >/dev/stderr
    exit 1
  fi
  encode=@BASE64@
fi

if [[ -n $ascii85 ]]; then
  encode=@ASCII85@
fi

shacmd=@SHA1SUM@

if [[ -n $sha ]]; then
  case $sha in
    512 ) shacmd=@SHA512SUM@ ;;
    384 ) shacmd=@SHA384SUM@ ;;
    256 ) shacmd=@SHA256SUM@ ;;
    224 ) shacmd=@SHA224SUM@ ;;
    1 ) shacmd=@SHA1SUM@ ;;
    * ) usage >/dev/stderr; exit 1 ;;
  esac
fi

declare -A digest_size
digest_size[@SHA1SUM@]=20
digest_size[@SHA224SUM@]=28
digest_size[@SHA256SUM@]=32
digest_size[@SHA384SUM@]=48
digest_size[@SHA512SUM@]=64

if (( ${digest_size[$shacmd]} <= $initial + $final - 1 )); then
  echo "You've discarded all ${digest_size[$shacmd]} digest bytes!" >/dev/stderr
  exit 1
fi
  
if [[ -z $salt && -z $random ]]; then
  get_salt
fi

# message buffer
message=$(mktemp)

# digest buffer
digest=$(mktemp)

# cleanup on exit
trap cleanup ERR EXIT RETURN INT QUIT TERM

if [[ -n $prologue ]]; then
  printf '%s' "$prologue" >>$message
fi

if [[ -n $salt ]]; then
  printf '%s' "$salt" >>$message
fi

if [[ -n $random ]]; then
  head --bytes=$random /dev/urandom >>$message
fi

if [[ -n $epilogue ]]; then
  printf '%s' "$epilogue" >>$message
fi

$shacmd $message | cut --delimiter=' ' --fields=1 | @XXD@ -r -p | \
  head --bytes=-$final | tail --bytes=+$initial >$digest

if [[ -n $text ]]; then
  # reuse message buffer
  output=$message
  @XXD@ -p $digest >$output
else
  output=$digest
fi

if [[ -n $uuencode ]]; then
  @UUENCODE@ $output /dev/stdout | sed -e '1d' -e '$d' | tr --delete '\n'
elif [[ -n $encode ]]; then
  $encode --wrap=0 $output
else
  cat $output
fi
